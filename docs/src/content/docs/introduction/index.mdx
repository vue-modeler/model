---
title: Введение
description: Обзор архитектуры и основных концепций Vue Modeler
---

**@vue-modeler/model** - библиотека для управления состоянием на основе моделей (реактивных объектов) для [Vue.js](https://vuejs.org/).

- сильно уменьшает объем шаблонного кода,
- реализует единый интерфейс для работы с реактивными объектами: свойствами и методами,
- сохраняет типизацию,
- поддерживает принципы ООП, DRY и SOLID.

## Ключевые концепции

- **Контейнер моделей**.
Фабрика создает поставщик модели. При первом вызове поставщик создает модель,
помещает его в контейнер и возвращает.
При следующих вызовах поставщик извлекает модель из контейнера.

- **Действие - объект с реактивным состоянием и поведением**.
Разработчик определяет действие как обычный асинхронный метод класса.
Снаружи работает с ним как реактивным объектом: запускает, отменяет, блокирует выполнение, следит за состоянием.
Действие уже содержит в себе реактивные свойства и методы для работы с состоянием. Дополнительный код не нужен.

- **Модель - совместно используемый объект**.
Контейнер моделей гарантирует, что модель остается в памяти, пока используется.
Контейнер удалит модель и вызовет деструктор, если она не используется в UI компонентах или других моделях.

## Ключевые особенности

- **Нет глобального хранилища состояния**.
  Нет хранилища — нет проблем. Состояние инкапсулировано в модели и является реактивным.
  Вне модели оно доступно только для чтения и наблюдения.

- **В основе ООП**.
  Модель определяется как стандартный TypeScript класс.
  Наследование, инкапсуляция, полиморфизм, деструктор доступны по умолчанию.

- **Поддержка внедрения зависимостей**.
  Модель принимает зависимости как аргументы конструктора, а не импортирует напрямую из других модулей.

- **Простое управление жизненным циклом модели**.
  Не нужно думать как создать, получить или удалить модель после использования -
  за это отвечает контейнер и провайдер.
  
- **Модульность**.
  Внедрение зависимостей избавляет от прямых импортов.
  Это позволяет легко извлекать связанные по смыслу модели в отдельные модули и использовать в других проектах.

- **Сохраняет типобезопасность**.
  Все подсказки автодополнения будут работать как внутри, так и вне контекста класса.

- **Реактивность Vue**. 
Всё работает на основе реактивности Vue. Не нужно изучать дополнительные API
или подходы для создания реактивных объектов.
  
---

## Причины создания 

### Шаблонный код в действиях

**Проблема:**
  Действия часто сопровождаются повторяющимся кодом для отслеживания состояния выполнения
  через дополнительные переменные: `isLoading`, `isPending`.
  В этом коде нет ценности для бизнес-логики, но он раздувает кодовую базу.

**Решение:**
 Действие - это объект с реактивными свойствами, отражающими статус его выполнения:
 `ready`, `pending`, `lock`, `abort`, `error`. Дополнительный код не нужен.

### Отмена или блокировка действия

**Проблема:** Отмена или блокировка действия не частая, но необходимая операция.
Все решают эту задачу по-своему, но в основе лежит общий паттерн.
Разные реализации одного и того же паттерна усложняют поддержку и повторное использование.

**Решение:** Действие содержит методы `lock` и `abort` для блокировки и отмены выполнения.
Не нужно писать дополнительный код и поддерживать его.

### Обработка исключений

**Проблема:** Обработка исключений дополнительный источник проблем: 
- разработчики забывают о ней,
- каждый разработчик обрабатывает её по-своему,
- регламенты не гарантируют, что  исключения будет обработано как нужно,
- обработка требует всегда внимательного ревью кода.

**Решение:** Действие перехватывает исключения, сохраняет их как часть состояния
и предоставляет единый интерфейс для обработки. Разработчик не сможет обрабатывать их по другому.

### Устаревшие паттерны

**Проблема:**  Pinia использует устаревший паттерн фабричной функции для создания хранилища.
Такое решение "тянет" за собой дополнительные шаблоны для эмуляции наследования и полиморфизма.

**Решение:** Поддержка классов и ООП из коробки.

### Слишком много реактивности 

**Проблема:** Хранилище Pinia - это объект с реактивными свойствами.
Но внутри фабричной функции это реактивные переменные, созданные с помощью Reactivity API Vue.
Получаем двойную реактивность и разные интерфейсы взаимодействия на одних и тех же данных.

**Решение:** Модели - это shallow reactive объекты из коробки.
Публичные и защищенные свойства будут реактивны снаружи и внутри 
без явного применения АПИ реактивности Vue.

## Следующие шаги

Теперь, когда вы понимаете основные концепции Vue Modeler, вы можете:

1. [Установить библиотеку](/installation/)
2. [Изучить быстрый старт](/getting-started/)
3. [Познакомиться с моделями](/guides/models/)
4. [Изучить действия](/guides/actions/) 