---
title: Введение
description: Обзор архитектуры и основных концепций Vue Modeler
---

**Vue modeler** - группа библиотек-инструментов разработчика. 
- уменьшает объем шаблонного кода,
- реализует единый интерфейс для работы с реактивными объектами: свойствами и методами,
- улучшает организацию кода,
- содержит набор инструментов для быстрой реализации шаблонных задач.

Состоит из пакетов:
- **@vue-modeler/dc** - контейнер зависимостей.
- **@vue-modeler/model** - библиотека для управления состоянием на основе моделей (реактивных объектов) для [Vue.js](https://vuejs.org/).
Основана на классах, сохраняет типизацию, поддерживает принципы ООП, DRY и SOLID.
- **@vue-modeler/kit** - набор абстрактных или универсальных моделей, 
реализующих частые шаблоны.

**@vue-modeler/model** - главная библиотека, содержит основной функционал, который чаще всего используется в разработке.
Она зависит от **@vue-modeler/dc** и использует его для создания shared моделей.

---

## @vue-modeler/dc


## @vue-modeler/model

### Ключевые концепции

- **Контейнер моделей**.
Фабрика создает поставщик модели. При первом вызове поставщик создает модель,
помещает его в контейнер и возвращает.
При следующих вызовах поставщик извлекает модель из контейнера.

- **Действие - объект с реактивным состоянием и поведением**.
Разработчик определяет действие как обычный асинхронный метод класса.
Снаружи работает с ним как реактивным объектом: запускает, отменяет, блокирует выполнение, следит за состоянием.

- **Модель - совместно используемый объект**.
Контейнер моделей гарантирует, что модель остается в памяти, пока используется.
Контейнер удалит модель и вызовет деструктор, если она не используется в UI компонентах или других моделях.

### Ключевые особенности

- **Нет глобального хранилища состояния**.
  Нет хранилища — нет проблем. Состояние инкапсулировано в модели и является реактивным.
  Вне модели оно доступно только для чтения и наблюдения.

- **В основе ООП**.
  Протомодель — стандартный TypeScript класс, модель — экземпляр класса.
  Наследование, инкапсуляция, полиморфизм, деструктор доступны по умолчанию.

- **Проще внедрять зависимости**.
  Не нужно думать как сохранить, получить или удалить модель после использования -
  за это отвечает контейнер и провайдер.
  В месте создания модели достаточно вызвать провайдер и передать зависимость в конструктор.

- **Модульность**.
  Внедрение зависимостей избавляет от прямых импортов.
  Это позволяет легко извлекать связанные по смыслу модели в отдельные модули и использовать в других проектах.

- **Сохраняет типобезопасность**.
  Все подсказки автодополнения будут работать как внутри, так и вне контекста класса.

- **Реактивность Vue**. 
Всё работает на основе реактивности Vue. Не нужно изучать дополнительные API
или подходы для создания реактивных объектов.
  
---

## Причины создания 

### Нет глобального хранилища состояния

**Проблема:** 

**Решение:**


### Шаблонный код в действиях

**Проблема:**
  Действия часто сопровождаются повторяющимся кодом для отслеживания состояния выполнения
  через дополнительные переменные: `isLoading`, `isPending`.
  Этот код добавляет мало ценности к бизнес-логике, но раздувает кодовую базу.

**Решение:**
 Действие - это объект с реактивными свойствами, отражающими статус его выполнения:
 `ready`, `pending`, `lock`, `abort`, `error`. Дополнительный код не нужен.

### Отмена или блокировка действия

**Проблема:** Отмена или блокировка действия не частая, но необходимая операция.
Все реализуют это по-своему, но в основе лежит общий паттерн.
Разные реализации одного и того же паттерна усложняют поддержку и повторное использование.

**Решение:** Действие содержит методы `lock` и `abort` для блокировки и отмены выполнения.
Не нужно писать дополнительный код и поддерживать его.

### Обработка исключений

**Проблема:** Обработка исключений дополнительный источник проблем: 
- разработчики забывают о ней,
- каждый разработчик обрабатывает её по-своему,
- регламенты не гарантируют, что  исключения будет обработано как нужно,
- обработка требует всегда внимательного ревью кода.

**Решение:** Действие перехватывает исключения, сохраняет их как часть состояния
и предоставляет единый интерфейс для обработки. Разработчик не сможет обрабатывать их по другому.

### Устаревшие паттерны

**Проблема:**  Pinia использует устаревший паттерн фабричной функции для создания хранилища.
Такое решение "тянет" за собой дополнительные шаблоны для эмуляции наследования и полиморфизма.

**Решение:** Поддержка классов и ООП из коробки.

### Слишком много реактивности 

**Проблема:** Хранилище Pinia - это объект с реактивными свойствами.
Но внутри фабричной функции это реактивные переменные, созданные с помощью Reactivity API Vue.
Получаем двойную реактивность и разные интерфейсы взаимодействия на одних и тех же данных.

**Решение:** Модели - это shallow reactive объекты из коробки.
Публичные и защищенные свойства будут реактивны снаружи и внутри 
без явного применения АПИ реактивности Vue.

## Следующие шаги

Теперь, когда вы понимаете основные концепции Vue Modeler, вы можете:

1. [Установить библиотеку](/installation/)
2. [Изучить быстрый старт](/getting-started/)
3. [Познакомиться с моделями](/guides/models/)
4. [Изучить действия](/guides/actions/) 